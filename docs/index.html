<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Kyphi Ingredient Aligner</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 1.5rem; }
  header { display:flex; align-items:baseline; gap:1rem; flex-wrap:wrap; }
  h1 { font-size: 1.25rem; margin: 0; }
  .panel { display:flex; gap:2rem; margin: 1rem 0; flex-wrap:wrap; }
  .block { min-width: 280px; }
  label { display:block; margin: .25rem 0; cursor: pointer; }
  input[type="search"] { width: 100%; padding:.5rem; border: 2px solid #ddd; border-radius: .4rem; transition: border-color 0.2s; }
  table { width:100%; border-collapse: collapse; margin-top: 1rem; }
  th, td { border-bottom: 1px solid #ddd; padding: .5rem .6rem; vertical-align: top; }
  th { position: sticky; top: 0; background: #fafafa; text-align:left; font-weight:600; }
  tbody tr:hover { background: #f8f8ff; }
  .pill { display:inline-block; padding:.1rem .4rem; border:1px solid #ccc; border-radius:999px; font-size:.75rem; margin-left:.25rem; }
  .muted { color:#666; font-size:.9rem; }
  .wrap { white-space: pre-wrap; }
  .controls { display:flex; gap:.5rem; flex-wrap:wrap; }
  .btn { padding:.45rem .7rem; border:1px solid #bbb; border-radius:.4rem; background:#fff; cursor:pointer; transition: transform 0.1s; }
  .btn:active { transform: translateY(1px); }
  .btn:hover { background: #f5f5f5; }
  .small { font-size:.85rem; }
  .note { color:#555; }
  .badge { font-size:.75rem; border:1px solid #ddd; border-radius:.4rem; padding:.1rem .35rem; background: #f8f8f8; }
  .badge.error { border-color: #ff6b6b; background: #ffe0e0; color: #d63031; }
  .center { text-align: center; }
  .message { padding: .5rem 1rem; margin: .5rem 0; border-radius: .4rem; font-size: .9rem; }
  .message.info { background: #e3f2fd; border-left: 4px solid #2196f3; }
  .message.success { background: #e8f5e8; border-left: 4px solid #51cf66; }
  .message.warning { background: #fff3cd; border-left: 4px solid #ffc107; }
  .message.error { background: #f8d7da; border-left: 4px solid #dc3545; }
  
  .alignment-mode { background: #e8f4fd; border: 1px solid #1976d2; border-radius: .4rem; padding: .5rem; margin: .5rem 0; }
  .best-guess { background: #fff3e0; border-left: 3px solid #ff9800; }
  .linked-ingredient { font-style: italic; opacity: 0.8; }
</style>
</head>
<body>
<header>
  <h1>Kyphi Ingredient Aligner</h1>
  <span class="muted">Data loads from <code>kyphi_long.json</code>.</span>
</header>

<div class="panel">
  <div class="block">
    <div class="controls">
      <button id="selectAll" class="btn small">Select all</button>
      <button id="selectNone" class="btn small">None</button>
      <button id="exportCSV" class="btn small">Export CSV</button>
      <button id="exportJSON" class="btn small">Export JSON</button>
    </div>
    <div id="recipeList" class="block" aria-label="Recipe selection"></div>
  </div>

  <div class="block">
    <label>
      Search ingredients / notes
      <input id="search" type="search" placeholder="e.g., σμύρνης, ḫrj, juniper, honey…">
    </label>
    <label><input type="checkbox" id="showAmounts" checked> Show amounts</label>
    <label><input type="checkbox" id="showPrep" checked> Show preparation</label>
    <label><input type="checkbox" id="showNotes" checked> Show notes</label>
    
    <div class="alignment-mode">
      <label><input type="checkbox" id="smartAlignment"> Smart Alignment Mode</label>
      <div class="muted small">Groups likely equivalent ingredients (myrrh, juniper, etc.) across languages</div>
    </div>
    
    <div class="muted small">Data: <span id="dataStatus" class="badge">loading…</span></div>
  </div>
</div>

<div id="alignmentWarning" class="message warning" style="display: none;">
  Smart Alignment active: Ingredients are grouped by best-guess equivalences. This view is speculative.
</div>

<table id="grid" aria-label="Aligned ingredients table">
  <thead id="thead"></thead>
  <tbody id="tbody"></tbody>
</table>

<script>
const DATA_URL = 'kyphi_long.json';
const EQUIVALENCES_URL = 'equivalences.json';  // Same directory as the web app
const SAMPLE_DATA = [
  {"recipe":"Philae","ingredient":"gnn","amount":null,"preparation":null,"notes":"unidentified"},
  {"recipe":"Dioscorides","ingredient":"σμύρνης","amount":"δραχμὰς 12","preparation":null,"notes":"myrrh"}
];

let equivalenceGroups = {}; // Loaded from file

async function loadEquivalences() {
  try {
    const r = await fetch(EQUIVALENCES_URL);
    if (!r.ok) {
      console.info('Equivalences file not found - smart alignment disabled');
      return {};
    }
    const data = await r.json();
    const groups = {};
    data.equivalence_groups.forEach(group => {
      groups[group.canonical_name] = group.ingredients;
    });
    console.log(`Loaded ${Object.keys(groups).length} equivalence groups`);
    return groups;
  } catch (error) {
    console.warn('Could not load equivalences:', error.message);
    return {};
  }
}

const nfkc = s => s && s.normalize ? s.normalize('NFKC') : s;
function unique(arr){ return Array.from(new Set(arr)); }

function download(filename, text){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([text],{type:'text/plain'}));
  a.download=filename;
  a.click();
  URL.revokeObjectURL(a.href);
}

function updateStatus(msg, isError = false) {
  const badge = document.getElementById('dataStatus');
  badge.textContent = msg;
  badge.className = `badge ${isError ? 'error' : ''}`;
}

function showMessage(msg, type = 'info') {
  const existing = document.getElementById('message');
  if (existing) existing.remove();
  
  const div = document.createElement('div');
  div.id = 'message';
  div.className = `message ${type}`;
  div.textContent = msg;
  document.querySelector('header').after(div);
  
  setTimeout(() => div.remove(), 3000);
}

function findEquivalenceGroup(ingredient) {
  const normalized = nfkc(ingredient).toLowerCase();
  for (const [groupName, variants] of Object.entries(equivalenceGroups)) {
    for (const variant of variants) {
      if (nfkc(variant).toLowerCase() === normalized || 
          normalized.includes(nfkc(variant).toLowerCase()) ||
          nfkc(variant).toLowerCase().includes(normalized)) {
        return groupName;
      }
    }
  }
  return null;
}

function getAlignedIngredients(ingredients, smartAlignment) {
  if (!smartAlignment) {
    return ingredients.map(ing => ({original: ing, aligned: ing, group: null}));
  }
  
  const grouped = {};
  const ungrouped = [];
  
  ingredients.forEach(ing => {
    const group = findEquivalenceGroup(ing);
    if (group) {
      if (!grouped[group]) grouped[group] = [];
      grouped[group].push(ing);
    } else {
      ungrouped.push(ing);
    }
  });
  
  const result = [];
  
  // Add grouped ingredients
  Object.entries(grouped).forEach(([groupName, ings]) => {
    result.push({
      original: ings,
      aligned: groupName,
      group: groupName,
      variants: ings
    });
  });
  
  // Add ungrouped ingredients
  ungrouped.forEach(ing => {
    result.push({original: ing, aligned: ing, group: null});
  });
  
  return result.sort((a, b) => a.aligned.localeCompare(b.aligned));
}

let rows=[], recipes=[], selected=new Set(), show={amounts:true, prep:true, notes:true}, searchTerm='', filteredCount = 0, smartAlignment = false;

async function loadJSON(url){
  updateStatus('Loading...', false);
  try { 
    const r = await fetch(url); 
    if (!r.ok) {
      console.warn(`Failed to fetch ${url}: ${r.status} ${r.statusText}`);
      return null;
    }
    const data = await r.json(); 
    if (!Array.isArray(data)) {
      throw new Error('Data is not an array');
    }
    return data;
  } catch (error) {
    console.warn(`Error loading ${url}:`, error.message);
    return null;
  }
}

function renderRecipeList(){
  const box=document.getElementById('recipeList'); box.innerHTML='';
  recipes.forEach(name=>{
    const id='r_'+name.replace(/\W+/g,'_');
    const wrap=document.createElement('label');
    wrap.innerHTML=`<input type="checkbox" id="${id}" ${selected.has(name)?'checked':''}> ${name}`;
    box.appendChild(wrap);
    wrap.querySelector('input').addEventListener('change', e=>{
      e.target.checked?selected.add(name):selected.delete(name);
      renderTable();
    });
  });
  document.getElementById('selectAll').onclick=()=>{ selected=new Set(recipes); renderRecipeList(); renderTable(); };
  document.getElementById('selectNone').onclick=()=>{ selected.clear(); renderRecipeList(); renderTable(); };
}

function renderTable(){
  const thead=document.getElementById('thead');
  const tbody=document.getElementById('tbody');
  const active=recipes.filter(r=>selected.has(r));
  const rawIngredients=unique(rows.map(r=>r.ingredient)).sort((a,b)=>a.localeCompare(b));
  
  // Show/hide alignment warning
  const warning = document.getElementById('alignmentWarning');
  warning.style.display = smartAlignment ? 'block' : 'none';
  
  if (active.length === 0) {
    thead.innerHTML = '<tr><th>Ingredient</th><th class="muted">No recipes selected</th></tr>';
    tbody.innerHTML = '<tr><td colspan="2" class="muted center">Select recipes from the left panel</td></tr>';
    filteredCount = 0;
    return;
  }
  
  // Get aligned ingredients
  const alignedIngredients = getAlignedIngredients(rawIngredients, smartAlignment);
  
  thead.innerHTML=`<tr><th>Ingredient${smartAlignment ? ' (Aligned)' : ''}</th>${active.map(r=>`<th>${r}</th>`).join('')}</tr>`;
  tbody.innerHTML='';
  const q=nfkc(searchTerm||'').toLowerCase();
  filteredCount = 0;
  
  alignedIngredients.forEach(alignedIng => {
    const tr=document.createElement('tr');
    
    // Build ingredient cell
    let ingredientDisplay = '';
    if (alignedIng.group) {
      // Show grouped ingredient
      ingredientDisplay = `<div class="wrap best-guess">
        <strong>${alignedIng.aligned}</strong><br>
        <small class="linked-ingredient">${alignedIng.variants.join(', ')}</small>
      </div>`;
    } else {
      ingredientDisplay = `<div class="wrap">${alignedIng.aligned}</div>`;
    }
    
    tr.innerHTML = `<td>${ingredientDisplay}</td>`;
    
    // Build recipe columns
    active.forEach(rec => {
      const relevantIngredients = alignedIng.group ? alignedIng.variants : [alignedIng.original];
      const matches = rows.filter(r => relevantIngredients.includes(r.ingredient) && r.recipe === rec);
      
      if (!matches.length) { 
        tr.innerHTML += `<td>—</td>`; 
        return; 
      }
      
      const cell = matches.map(m => {
        const bits = [`<strong>${m.ingredient}</strong>`];
        if (show.amounts && m.amount) bits.push(`<span class="pill">${m.amount}</span>`);
        if (show.prep && m.preparation) bits.push(`<span class="pill">${m.preparation}</span>`);
        if (show.notes && m.notes) bits.push(`<span class="note">${m.notes}</span>`);
        return bits.join(' ');
      }).join('<br>');
      tr.innerHTML += `<td>${cell}</td>`;
    });
    
    // Search filter
    const textBlob = (alignedIng.aligned + ' ' + tr.textContent).toLowerCase();
    if (q && !textBlob.includes(q)) return;
    tbody.appendChild(tr);
    filteredCount++;
  });
  
  // Show search results feedback
  const searchInput = document.getElementById('search');
  if (q) {
    const totalIngredients = alignedIngredients.length;
    if (filteredCount === 0) {
      searchInput.style.borderColor = '#ff6b6b';
      showMessage(`No ingredients found matching "${searchTerm}"`, 'warning');
    } else {
      searchInput.style.borderColor = '#51cf66';
      if (filteredCount < totalIngredients) {
        showMessage(`Found ${filteredCount} of ${totalIngredients} ingredients`, 'success');
      }
    }
  } else {
    searchInput.style.borderColor = '#ddd';
  }
}

addEventListener('DOMContentLoaded', async ()=>{
  // Load equivalences first
  equivalenceGroups = await loadEquivalences();
  console.log(`Loaded ${Object.keys(equivalenceGroups).length} equivalence groups`);
  
  let data = await loadJSON(DATA_URL);
  let statusMsg = '';
  
  if (!data) {
    console.info('Using sample data (kyphi_long.json not found or invalid)');
    data = SAMPLE_DATA;
    statusMsg = 'sample data (file not found)';
    updateStatus(statusMsg, true);
    showMessage('Could not load kyphi_long.json - using sample data', 'warning');
  } else {
    statusMsg = `${data.length} entries loaded`;
    updateStatus(statusMsg, false);
    if (data.length === 0) {
      showMessage('Data file is empty - add some diffs and rebuild!', 'info');
    }
  }
  
  // Validate and clean data
  const validRows = [];
  data.forEach((row, i) => {
    if (!row.recipe || !row.ingredient) {
      console.warn(`Skipping invalid row ${i}:`, row);
      return;
    }
    validRows.push(row);
  });
  
  if (validRows.length < data.length) {
    showMessage(`Filtered out ${data.length - validRows.length} invalid rows`, 'warning');
  }
  
  rows = validRows.map(r=>({
    recipe: nfkc(r.recipe),
    ingredient: nfkc(r.ingredient),
    amount: r.amount ?? null,
    preparation: r.preparation ?? null,
    notes: r.notes ?? null
  }));
  
  recipes = unique(rows.map(r=>r.recipe)).sort((a,b)=>a.localeCompare(b, undefined, {numeric:true}));
  selected = new Set(recipes);
  
  document.getElementById('dataStatus').title = `${rows.length} total entries from ${recipes.length} recipes`;
  
  renderRecipeList();
  renderTable();
  
  // Event listeners
  document.getElementById('search').addEventListener('input', e=>{ 
    searchTerm=e.target.value; 
    renderTable(); 
  });
  
  document.getElementById('showAmounts').addEventListener('change', e=>{ 
    show.amounts=e.target.checked; 
    renderTable(); 
  });
  
  document.getElementById('showPrep').addEventListener('change', e=>{ 
    show.prep=e.target.checked; 
    renderTable(); 
  });
  
  document.getElementById('showNotes').addEventListener('change', e=>{ 
    show.notes=e.target.checked; 
    renderTable(); 
  });
  
  document.getElementById('smartAlignment').addEventListener('change', e=>{
    smartAlignment = e.target.checked;
    renderTable();
    if (smartAlignment && Object.keys(equivalenceGroups).length === 0) {
      showMessage('No equivalences loaded - add equivalences.json for smart alignment', 'warning');
    } else if (smartAlignment) {
      showMessage('Smart alignment activated - showing best-guess equivalences', 'info');
    }
  });
  
  // Fixed CSV export
  document.getElementById('exportCSV').addEventListener('click', ()=>{
    if (rows.length === 0) {
      showMessage('No data to export', 'warning');
      return;
    }
    
    const headers = ['recipe', 'ingredient', 'amount', 'preparation', 'notes'];
    const csvRows = [headers.join(',')];
    
    rows.forEach(row => {
      const values = headers.map(header => {
        const value = row[header] || '';
        return /[,"\n\r]/.test(value) ? `"${value.replace(/"/g, '""')}"` : value;
      });
      csvRows.push(values.join(','));
    });
    
    download('kyphi_aligned.csv', csvRows.join('\n'));
    showMessage(`Exported ${rows.length} rows to CSV`, 'success');
  });
  
  document.getElementById('exportJSON').addEventListener('click', ()=>{ 
    if (rows.length === 0) {
      showMessage('No data to export', 'warning');
      return;
    }
    download('kyphi_long.json', JSON.stringify(rows, null, 2)); 
    showMessage(`Exported ${rows.length} rows to JSON`, 'success');
  });
});
</script>
</body>
</html>